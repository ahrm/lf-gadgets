#!/usr/bin/env zsh
# We use zsh for its convenience around arrays, especially for subsetting $@.

cleanup() {
	if [ -z "$nocleanup" ]; then
		rm -rf "$LF_FILEDIALOG_TEMPDIR"
	fi
	if [ -n "$1" ]; then
		exit "$1"
	fi
}

usage() {
	if [ -t 1 ]; then
		hl="$(printf "\033[1;3m")"
		i="$(printf "\033[3m")"
		p="$(printf "\033[3;4m")"
		d="$(printf "\033[0m")"
	fi
	cat <<EOF
Pick files with ${hl}lf${d} and print their paths.

Press ${i}return${d} to choose the currently selected file or use the command
'${i}new <FILENAME>${d}' to print a new filename.

Usage:
    ${hl}${ZSH_ARGZERO:t}${d} [-t ${p}TYPE${d}] [-s ${p}STARTDIR${d}] [-o ${p}OUTFILE${d}] [-p ${p}PROMPT${d}]
              [-x [${p}TERMARGS${d}]...]

        -t ${p}TYPE${d}   Specify what type of object(s) to return. May
            be any combination of the letters ${i}f${d} (files),
            ${i}d${d} (directories). DEFAULT: fd

        -s ${p}STARTDIR${d}   Set the dialog's default working directory.
            DEFAULT: Working directory of the executing shell

        -o ${p}OUTFILE${d}   Write output to ${p}OUTFILE${d} instead of stdout.
            Can be invoked multiple times. DEFAULT: None

        -p ${p}PROMPT${d}   Configure the dialog prompt. DEFAULT: 'Select files(s):'

        -x ${p}TERMARGS${d}   Display dialog in a new terminal window using
            the \$TERMINAL envvar. Optional ${p}TERMARGS${d} may be used to
            pass parameters to the terminal. MUST be the last option
            if present. DEFAULT: None
EOF
}

# Set up the tempdir and export its path, unless the corresponding envvar
# is already defined. This mechanism is used to implement the -x option
# and it is useful for debugging.
if [ -z "$LF_FILEDIALOG_TEMPDIR" ]; then
	LF_FILEDIALOG_TEMPDIR="$(mktemp -d -t lf-filedialog-XXXXXX)"
	export LF_FILEDIALOG_TEMPDIR
else
	nocleanup=1
fi

trap cleanup INT HUP

# If there's a -h or --help anywhere, print usage and abort.
if [ $@[(ie)-h] -le $# ] || [ $@[(ie)--help] -le $# ]; then
	usage
	cleanup 0
fi

# If the -x option is set, the script launches itself in a new terminal.
# Existing options are passed to the call and any trailing terminal arguments
# are forwarded aswell (hence the necessity for -x to be the last option).
#
# As we cannot capture the terminal's stdout, the script writes the selection
# to a file instead using the -o option (this does not interfere with any
# existing usages of -o, as this option may be used multiple times). Afterwards,
# the contents of the file are retrieved and printed out.
tempfile="$LF_FILEDIALOG_TEMPDIR/termout"
x_at="$@[(ie)-x]"
if [ "$x_at" -le $# ]; then
	if [ -z "$TERMINAL" ]; then
		echo "\$TERMINAL is not set. Abort." >&2
		cleanup 1
	fi
	term_args=("${@:$((x_at + 1))}")
	dialog_args=("${@:1:$((x_at - 1))}")
	if "$TERMINAL" $term_args -e "$ZSH_ARGZERO" $dialog_args -o "$tempfile" >/dev/null 2>&1; then
		# suppress output to stdout if -o was used.
		if [ "${dialog_args[(ie)-o]}" -gt ${#dialog_args[@]} ]; then
			cat "$tempfile"
		fi
		cleanup 0
	fi
	cleanup 1
else
	for ((ii=1; ii<=${#@}; ii++)); do
		case "$@[ii]" in
		-t) type_="$@[ii+1]"; ((ii++)) ;;
		-s) startdir="$@[ii+1]"; ((ii++)) ;;
		-o) outfiles=($outfiles "$@[ii+1]"); ((ii++)) ;;
		-p) prompt="$@[ii+1]"; ((ii++)) ;;
		*) echo "Unknown option '$@[ii]'. Abort." >&2; cleanup 1 ;;
		esac
	done
fi

# Configure defaults.
startdir="${startdir:-$(pwd)}"
type_="${type_:-fd}"
prompt="${prompt:-Select file(s):}"

# Here we launch lf. Defaults are communicated via environment variables which
# are referenced during startup.
export LF_FILEDIALOG_TYPE="$type_"
export LF_FILEDIALOG_PROMPT="$prompt"
lf -command "source '${XDG_CONFIG_HOME:-$HOME/.config}/lf-filedialog/lfrc-filedialog" "$startdir"

# Print the output to stdout or to any output files.
if [ -f "$LF_FILEDIALOG_TEMPDIR/selection" ]; then
	if [ ${#outfiles} -eq 0 ]; then
		cat "$LF_FILEDIALOG_TEMPDIR/selection"
	else
		for file in $outfiles; do
			cat "$LF_FILEDIALOG_TEMPDIR/selection" >"$file"
		done
	fi
	cleanup 0
else
	cleanup 1
fi

# TODO:
#  -m: multiple files
#  -z: Use nullbyte as separator for multiple files
